<style>
  /* ALL CSS FROM ORIGINAL piano_editor_with_tooltips (3).html AND newUIs.css merged here.
     This block should eventually be moved to your pianostyles.css file. */

  * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
  }

  body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      min-height: 100vh;
      color: white;
  }

  .container {
      display: flex;
      height: 100vh;
  }

  .main-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 20px;
  }

  .header {
      text-align: center;
      margin-bottom: 20px;
  }

  .header h1 {
      font-size: 2.5rem;
      background: linear-gradient(45deg, #4ade80, #22d3ee);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
  }

  .playback-controls {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-bottom: 30px;
  }

  .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
      backdrop-filter: blur(10px);
  }

  .btn:hover {
      background: rgba(255, 255, 255, 0.2);
  }

  .btn.primary {
      background: #4ade80;
      color: #1f2937;
  }

  .score-container {
      flex: 1;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 12px;
      padding: 20px;
      position: relative;
      overflow: auto;
  }

  /* Note Palette */
  .note-palette-container {
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
  }

  .palette-header {
      color: white;
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 10px;
      text-align: center;
  }

  .note-palette {
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
  }

  .palette-note {
      width: 60px;
      height: 45px;
      background: rgba(255, 255, 255, 0.9);
      border: 2px solid white;
      border-radius: 8px;
      color: #1f2937;
      cursor: grab;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: 700;
      transition: all 0.2s;
      user-select: none;
  }

  .palette-note:hover {
      background: white;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
  }

  .palette-note:active {
      cursor: grabbing;
  }

  .note-duration {
      font-size: 9px;
      margin-top: 2px;
      opacity: 0.7;
      font-weight: 500;
  }

  .chord-major {
      background: linear-gradient(135deg, #22c55e, #16a34a) !important;
      color: white !important;
      border-color: #22c55e !important;
  }

  .chord-minor {
      background: linear-gradient(135deg, #a855f7, #9333ea) !important;
      color: white !important;
      border-color: #a855f7 !important;
  }

  .palette-separator {
      width: 2px;
      height: 40px;
      background: rgba(255, 255, 255, 0.4);
      margin: 0 5px;
  }

  /* Staff styling (original from mockup, not VexFlow rendering) */
  .staff {
      position: relative;
      height: 120px;
      margin: 40px 0;
  }

  .staff-lines {
      position: absolute;
      width: 100%;
      height: 100%;
  }

  .staff-line {
      position: absolute;
      width: 100%;
      height: 1px;
      background: #333;
      left: 0;
  }

  .staff-line:nth-child(1) { top: 20%; }
  .staff-line:nth-child(2) { top: 35%; }
  .staff-line:nth-child(3) { top: 50%; }
  .staff-line:nth-child(4) { top: 65%; }
  .staff-line:nth-child(5) { top: 80%; }

  .measure {
      display: inline-block;
      width: 200px;
      height: 120px;
      border-right: 2px solid #333;
      position: relative;
      cursor: pointer;
      transition: all 0.2s;
  }

  .measure:hover {
      background: rgba(34, 197, 94, 0.1);
  }

  .measure.selected {
      background: rgba(34, 197, 94, 0.15);
      box-shadow: inset 0 0 0 2px #22c55e;
  }

  .note {
      position: absolute;
      width: 24px;
      height: 16px;
      background: #1f2937;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s;
      user-select: none;
  }

  .note:hover {
      background: #374151;
  }

  .note.selected {
      background: #f97316;
      box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.3);
      z-index: 10;
  }

  .note.chord {
      background: linear-gradient(45deg, #3b82f6, #1d4ed8);
      border-radius: 50% 50% 30% 30%;
      position: relative;
  }

  .note.chord::after {
      content: '';
      position: absolute;
      top: -4px;
      left: 2px;
      width: 16px;
      height: 12px;
      background: linear-gradient(45deg, #60a5fa, #3b82f6);
      border-radius: 50% 50% 30% 30%;
  }

  .note.chord::before {
      content: '';
      position: absolute;
      top: -8px;
      left: 4px;
      width: 12px;
      height: 10px;
      background: linear-gradient(45deg, #93c5fd, #60a5fa);
      border-radius: 50% 50% 30% 30%;
      z-index: 1;
  }

  /* Sample notes positioning */
  .note1 { top: 45%; left: 30px; }
  .note2 { top: 35%; left: 80px; }
  .note3 { top: 55%; left: 130px; }
  .note4 { top: 25%; left: 30px; }
  .note5 { top: 45%; left: 80px; }
  .note6 { top: 65%; left: 130px; }

  /* Context Menu */
  .context-menu {
      position: fixed;
      background: white;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      padding: 8px 0;
      z-index: 3000;
      display: none;
      min-width: 150px;
  }

  .context-menu.visible {
      display: block;
  }

  .context-menu-item {
      padding: 10px 16px;
      color: #374151;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
  }

  .context-menu-item:hover {
      background: #f3f4f6;
  }

  .context-menu-separator {
      height: 1px;
      background: #e5e7eb;
      margin: 4px 0;
  }

  /* Drop zones */
  .ghost-note {
      position: absolute;
      width: 24px;
      height: 16px;
      background: rgba(34, 197, 94, 0.6);
      border: 2px dashed #22c55e;
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
      z-index: 100;
  }

  .ghost-note.visible {
      opacity: 1;
  }

  /* Editing Panel - Added from tool tip.html */
  .editing-panel {
      position: fixed;
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
      padding: 16px;
      z-index: 4000;
      /* display: none; */ /* Will be managed by JS visible class */
      border: 2px solid #3b82f6;
      min-width: 280px;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
  }

  .editing-panel.visible {
      display: block;
      animation: panelSlideIn 0.3s ease-out forwards;
  }

  @keyframes panelSlideIn {
      from { opacity: 0; transform: translateY(-10px) scale(0.98); }
      to { opacity: 1; transform: translateY(0) scale(1); }
  }

  .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #e5e7eb;
  }

  .panel-header-buttons {
      display: flex;
      gap: 8px;
      align-items: center;
  }

  .panel-title {
      font-weight: 700;
      color: #1f2937;
      font-size: 16px;
  }

  .panel-close, .panel-dock {
      background: none;
      border: none;
      color: #64748b;
      cursor: pointer;
      font-size: 18px;
      padding: 4px;
      line-height: 1;
      border-radius: 4px;
      transition: all 0.2s;
  }

  .panel-close:hover, .panel-dock:hover {
      background: rgba(100, 116, 139, 0.1);
      color: #374151;
  }

  .editing-panel.docked {
      position: relative !important;
      left: auto !important;
      top: auto !important;
      transform: none !important;
      border: 1px solid #475569;
      background: rgba(30, 41, 59, 0.95);
      backdrop-filter: blur(10px);
      min-width: auto;
      width: 100%;
      margin-top: 0;
  }

  .editing-panel.docked .panel-title {
      color: white;
  }

  .editing-panel.docked .panel-close,
  .editing-panel.docked .panel-dock {
      color: #94a3b8;
  }

  .editing-panel.docked .panel-close:hover,
  .editing-panel.docked .panel-dock:hover {
      background: rgba(255, 255, 255, 0.1);
      color: white;
  }

  .editing-panel.docked .control-label {
      color: #94a3b8;
  }

  .editing-panel.docked .control-btn {
      background: rgba(255, 255, 255, 0.1);
      border-color: #475569;
      color: #e2e8f0;
  }

  .editing-panel.docked .control-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: #3b82f6;
  }

  .editing-panel.docked .control-btn.active {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
  }

  .editing-panel.docked .dropdown-select {
      background: rgba(255, 255, 255, 0.1);
      border-color: #475569;
      color: #e2e8f0;
  }

  .editing-panel.docked #currentPitch {
      color: white;
  }

  .panel-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
  }

  .control-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
  }

  .control-label {
      font-size: 13px;
      color: #4a5568;
      min-width: 60px;
      font-weight: 600;
  }

  .control-btn {
      padding: 8px 12px;
      border: 1px solid #cbd5e0;
      border-radius: 8px;
      background: white;
      color: #374151;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
  }

  .control-btn:hover {
      background: #f0f4f8;
      border-color: #3b82f6;
      color: #1a202c;
  }

  .control-btn.active {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
  }

  .control-btn-icon {
      font-size: 1.2em;
      margin-right: 4px;
  }

  /* original mockup's #currentPitch styling */
  /* This style will be applied via the input field in editorSelectedNoteDisplay */
  /*
  #currentPitch {
      font-weight: bold;
      font-size: 1.1em;
      color: #1f2937;
      min-width: 40px;
      text-align: center;
  }
  */

  .dropdown-select {
      padding: 6px 8px;
      border: 1px solid #cbd5e0;
      border-radius: 6px;
      background-color: white;
      font-size: 13px;
      color: #374151;
      cursor: pointer;
  }

  /* Side panel */
  .side-panel {
      width: 280px;
      background: rgba(30, 41, 59, 0.95);
      backdrop-filter: blur(10px);
      padding: 20px;
      border-radius: 12px 0 0 12px;
  }

  .panel-section {
      margin-bottom: 24px;
  }

  .panel-section h3 {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
  }

  .measure-nav {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 16px;
  }

  .measure-input {
      width: 60px;
      padding: 8px;
      border: 1px solid #475569;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      text-align: center;
  }

  .nav-btn {
      padding: 8px 12px;
      border: 1px solid #475569;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      cursor: pointer;
      font-size: 12px;
  }

  .nav-btn:hover {
      background: rgba(255, 255, 255, 0.2);
  }

  .nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
  }

  .side-controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
  }

  .side-btn {
      padding: 10px 12px;
      border: 1px solid #475569;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
      text-align: left;
  }

  .side-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: #3b82f6;
  }

  .side-btn:active {
      background: rgba(59, 130, 246, 0.3);
  }

  @media (max-width: 1024px) {
      .container {
          flex-direction: column;
      }

      .side-panel {
          width: 100%;
          border-radius: 0;
          order: -1;
      }

      .editing-panel {
          min-width: unset;
          width: 90%;
          left: 5%;
          top: 20px;
          transform: translateX(0);
      }
  }

  /* Styles for the old editor parts now integrated */
  #editorContainer {
      /* This will style the OLD editor part when it's moved into the side panel. */
      /* You might want to adjust width/flex behavior for integration */
      width: 100%; /* Example */
      max-width: 100%; /* Example */
      background: rgba(255, 255, 255, 0.05); /* Slightly different background for distinction */
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }
  #editorEditBox {
      display: flex;
      flex-direction: column;
      gap: 15px;
  }
  #editorExpandedEditorOriginal { /* Targeting the original expanded editor */
      border-top: 1px solid rgba(255,255,255,0.1);
      padding-top: 15px;
      margin-top: 15px;
  }
  .control-button {
      /* General button styling for old editor controls */
      padding: 8px 12px;
      border-radius: 6px;
      background-color: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
      cursor: pointer;
      transition: background-color 0.2s, border-color 0.2s;
  }
  .control-button:hover {
      background-color: rgba(255, 255, 255, 0.2);
  }
  .notes-container {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      border: 1px dashed rgba(255,255,255,0.1);
      padding: 10px;
      min-height: 60px;
      border-radius: 4px;
      align-items: center;
  }
  .note-select {
      padding: 5px 10px;
      background-color: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      color: white;
      cursor: pointer;
  }
  .note-select.active-note-select {
      background-color: #4ade80; /* Primary green */
      color: #1f2937;
      border-color: #4ade80;
  }
  /* Specific styles for the old input to match new measure-input */
  #editorNumberInputOriginal {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      width: 60px; /* Match new UI's measure-input width */
      padding: 8px; /* Match new UI's measure-input padding */
      border-radius: 6px; /* Match new UI's measure-input border-radius */
      text-align: center;
  }
</style>

<div class="container">
  <div class="side-panel">
      <div id="editorContainer">
          <div id="editorEditBox">
              <div id="editorExpandedEditorOriginal" class="hidden"> {# Renamed ID to avoid conflict with editingPanel #}
                  <h3>Editing: <span id="editorSelectedNoteDisplayOriginal"></span></h3>

                  <div id="singleNoteControls">
                      <div class="control-group">
                          <label for="editorNoteLetter">Letter:</label>
                          <select id="editorNoteLetter">
                              <option value="C">C</option><option value="D">D</option><option value="E">E</option>
                              <option value="F">F</option><option value="G">G</option><option value="A">A</option>
                              <option value="B">B</option><option value="R">R (Rest)</option>
                          </select>
                      </div>

                      <div class="control-group">
                          <label for="editorAccidentalDropdownOriginal">Accidental:</label> {# Renamed ID #}
                          <select id="editorAccidentalDropdownOriginal">
                              <option value="">None</option><option value="#">#</option><option value="b">b</option>
                          </select>
                      </div>

                      <div class="control-group">
                          <label for="editorOctaveDropdownOriginal">Octave:</label> {# Renamed ID #}
                          <select id="editorOctaveDropdownOriginal">
                              <option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option><option value="6">6</option><option value="7">7</option>
                          </select>
                      </div>
                  </div>

                  <div id="chordNotesEditor" class="hidden">
                      <h4>Chord Notes:</h4>
                      <div id="chordNotesContainer">
                          {# Chord note inputs will be dynamically populated here #}
                      </div>
                      <button id="addNoteToChordBtn" class="control-button bg-green-500 hover:bg-green-600">Add Note to Chord</button>
                  </div>

                  <div class="control-group">
                      <label>Remove Selected:</label>
                      <button id="editorRemoveNoteOriginal" class="control-button bg-red-500 hover:bg-red-600">Remove</button> {# Renamed ID #}
                  </div>

                  <div class="control-group">
                      <label>Change Clef:</label>
                      <button id="editorToggleClefOriginal" class="control-button bg-gray-500 hover:bg-gray-600">Treble</button> {# Renamed ID #}
                  </div>

                  <div class="control-group">
                      <label>Toggle Rest:</label>
                      <button id="editorToggleRestOriginal" class="control-button bg-gray-500 hover:bg-gray-600">Toggle</button> {# Renamed ID #}
                  </div>

                  <div class="control-group">
                      <label for="editorDurationDropdownOriginal">Duration:</label> {# Renamed ID #}
                      <select id="editorDurationDropdownOriginal">
                          {# Duration options will be populated by JavaScript #}
                      </select>
                  </div>

                  <div class="control-group">
                      <label>Move Note:</label>
                      <button id="editorMoveToPrevMeasureOriginal" class="control-button bg-purple-500 hover:bg-purple-600">Move to Previous Measure</button> {# Renamed ID #}
                      <button id="editorMoveToNextMeasureOriginal" class="control-button bg-purple-500 hover:bg-purple-600">Move to Next Measure</button> {# Renamed ID #}
                  </div>
              </div>

              <h2 id="editorControlsHeader">
                  <span>Measure</span>
                  <button id="editorPrevBtnOriginal" class="control-button">-</button> {# Renamed ID #}
                  <input type="number" id="editorNumberInputOriginal" value="1" min="1"> {# Renamed ID #}
                  <button id="editorNextBtnOriginal" class="control-button">+</button> {# Renamed ID #}
              </h2>

              <div>
                  <h3>Treble Clef Notes:</h3>
                  <div id="editorTrebleNotesContainer" class="notes-container">
                      {# Treble clef notes will be populated by JavaScript #}
                  </div>

                  <h3>Bass Clef Notes:</h3>
                  <div id="editorBassNotesContainer" class="notes-container">
                      {# Bass clef notes will be populated by JavaScript #}
                  </div>
              </div>
          </div>
      </div>
      <div class="panel-section">
          <h3>Navigation</h3>
          <div class="measure-nav">
              <button class="nav-btn" disabled id="editorPrevBtn">◀</button>
              <input type="number" class="measure-input" value="2" min="1" id="editorNumberInput">
              <button class="nav-btn" id="editorNextBtn">▶</button>
              <span style="color: #94a3b8; font-size: 12px;">of 4</span>
          </div>
      </div>

      <div class="panel-section">
          <h3>Add Notes</h3>
          <div class="side-controls">
              <button class="side-btn">♩ Treble</button>
              <button class="side-btn">♩ Bass</button>
          </div>
      </div>

      <div class="panel-section">
          <h3>Add Chords</h3>
          <div class="side-controls">
              <button class="side-btn">♩♩♩ Treble</button>
              <button class="side-btn">♩♩♩ Bass</button>
          </div>
      </div>

      <div class="panel-section">
          <h3>Rests</h3>
          <div class="side-controls">
              <button class="side-btn">𝄽 Add Rest</button>
              <button class="side-btn">Fill Measure</button>
          </div>
      </div>

      <div id="dockedEditingContainer" class="panel-section">
          <h3>Edit Note</h3>
      </div>
  </div>

  <div class="main-area">
      <div class="header">
          <h1>Piano Tour</h1>
      </div>

      <div class="playback-controls">
          <button class="btn primary">▶ Play Score</button>
          <button class="btn">⏹ Stop</button>
          <button class="btn">🎹 Connect MIDI</button>
      </div>

      <div class="score-container">
          <div class="note-palette-container">
              <div class="palette-header">Drag notes to score, right-click staff lines, or click notes to edit</div>
              <div class="note-palette">
                  <div class="palette-note" draggable="true" data-type="quarter">
                      ♩
                      <div class="note-duration">Quarter</div>
                  </div>
                  <div class="palette-note" draggable="true" data-type="eighth">
                      ♪
                      <div class="note-duration">Eighth</div>
                  </div>
                  <div class="palette-note" draggable="true" data-type="half">
                      ♫
                      <div class="note-duration">Half</div>
                  </div>
                  <div class="palette-note" draggable="true" data-type="whole">
                      𝅗𝅥
                      <div class="note-duration">Whole</div>
                  </div>
                  <div class="palette-note" draggable="true" data-type="rest">
                      𝄽
                      <div class="note-duration">Rest</div>
                  </div>
                  <div class="palette-separator"></div>
                  <div class="palette-note chord-major" draggable="true" data-type="major">
                      ♩♩♩
                      <div class="note-duration">Major</div>
                  </div>
                  <div class="palette-note chord-minor" draggable="true" data-type="minor">
                      ♩♩♩
                      <div class="note-duration">Minor</div>
                  </div>
              </div>
          </div>

          <div id="newUIRenderScoreWrap" style="
              width: 100%;
              background: rgba(229, 231, 235, 0.95);
              color: var(--dark-bg);
              border: 1px solid var(--glass-border);
              border-radius: var(--border-radius-lg);
              padding: 1rem;
              box-shadow: var(--shadow-lg);
              transition: var(--transition);
              overflow-x: auto;
              scroll-behavior: smooth;
              text-align: center;
              margin-top: 20px; /* Added some margin to separate from palette */
          ">
              <div id="newUIRenderScore" style="
                  display: inline-block;
                  min-width: fit-content;
                  text-align: left;
                  padding-bottom: 1rem;
              "></div>
          </div>

          <div class="score-area">
              <div class="ghost-note" id="ghost-note"></div>

              <div class="staff" data-clef="treble">
                  <div class="staff-lines">
                      <div class="staff-line"></div>
                      <div class="staff-line"></div>
                      <div class="staff-line"></div>
                      <div class="staff-line"></div>
                      <div class="staff-line"></div>
                  </div>

                  <div class="measure">
                      <div class="note note1" data-pitch="G4"></div>
                      <div class="note note2" data-pitch="C5"></div>
                      <div class="note note3" data-pitch="E4"></div>
                  </div>

                  <div class="measure selected">
                      <div class="note note1 chord" data-pitch="C4"></div>
                      <div class="note note2" data-pitch="A4"></div>
                  </div>

                  <div class="measure">
                      <div class="note note1" data-pitch="F4"></div>
                      <div class="note note2" data-pitch="D5"></div>
                  </div>

                  <div class="measure">
                      <div class="note note1" data-pitch="B4"></div>
                  </div>
              </div>

              <div class="staff" data-clef="bass">
                  <div class="staff-lines">
                      <div class="staff-line"></div>
                      <div class="staff-line"></div>
                      <div class="staff-line"></div>
                      <div class="staff-line"></div>
                      <div class="staff-line"></div>
                  </div>

                  <div class="measure">
                      <div class="note note4" data-pitch="G2"></div>
                      <div class="note note5" data-pitch="C3"></div>
                      <div class="note note6" data-pitch="F2"></div>
                  </div>

                  <div class="measure selected">
                      <div class="note note4" data-pitch="A2"></div>
                      <div class="note note5" data-pitch="D3"></div>
                  </div>

                  <div class="measure">
                      <div class="note note4" data-pitch="E2"></div>
                      <div class="note note5" data-pitch="B2"></div>
                  </div>

                  <div class="measure">
                  </div>
              </div>
          </div>

      </div>
  </div>
</div>

<div class="context-menu" id="contextMenu">
  <div class="context-menu-item" data-type="quarter">♩ Quarter Note</div>
  <div class="context-menu-item" data-type="eighth">♪ Eighth Note</div>
  <div class="context-menu-item" data-type="half">♫ Half Note</div>
  <div class="context-menu-item" data-type="whole">𝅗𝅥 Whole Note</div>
  <div class="context-menu-separator"></div>
  <div class="context-menu-item" data-type="rest">𝄽 Rest</div>
  <div class="context-menu-separator"></div>
  <div class="context-menu-item" data-type="major">♩♩♩ Major Chord</div>
  <div class="context-menu-item" data-type="minor">♩♩♩ Minor Chord</div>
</div>

<div class="editing-panel" id="editingPanel">
  <div class="panel-header">
      <span class="panel-title">Editing: <input type="text" id="editorSelectedNoteDisplay" value="C4" maxlength="4" style="border:none; background:none; font-weight:bold; font-size:1em; color:#1f2937; min-width:40px; text-align:center; padding:0;"/></span>
      <div class="panel-header-buttons">
          <button class="panel-dock" aria-label="Dock to sidebar">◀</button>
          <button class="panel-close" aria-label="Close panel">✕</button>
      </div>
  </div>
  <div class="panel-controls">
      <div class="control-group">
          <span class="control-label">Pitch:</span>
          <button class="control-btn" aria-label="Pitch Up">⬆️</button>
          <button class="control-btn" aria-label="Pitch Down">⬇️</button>
      </div>
      <div class="control-group">
          <span class="control-label">Duration:</span>
          <button class="control-btn active" data-duration="q" aria-label="Quarter Note"><span class="control-btn-icon">♩</span></button>
          <button class="control-btn" data-duration="8" aria-label="Eighth Note"><span class="control-btn-icon">♪</span></button>
          <button class="control-btn" data-duration="h" aria-label="Half Note"><span class="control-btn-icon">♫</span></button>
          <button class="control-btn" data-duration="w" aria-label="Whole Note">𝅗𝅥</button>
          <select id="editorDurationDropdown" style="display:none;" aria-hidden="true">
              <option value="q">Quarter</option>
              <option value="8">Eighth</option>
              <option value="h">Half</option>
              <option value="w">Whole</option>
              <option value="16">Sixteenth</option>
              <option value="32">Thirty-second</option>
          </select>
          <button class="control-btn" data-dotted="true" aria-label="Add Dot">●</button>
      </div>
      <div class="control-group">
          <span class="control-label">Type:</span>
          <button class="control-btn active" data-type="note" aria-label="Note Type">Note</button>
          <button class="control-btn" data-type="chord" aria-label="Chord Type">Chord</button>
          <button class="control-btn" data-type="rest" aria-label="Rest Type" id="editorToggleRest">Rest</button>
      </div>
      <div class="control-group">
          <span class="control-label">Clef:</span>
          <button class="control-btn" aria-label="Toggle Clef" id="editorToggleClef">Toggle Treble/Bass</button>
      </div>
      <div class="control-group">
          <span class="control-label">Octave:</span>
          <select id="editorOctaveDropdown" class="dropdown-select" aria-label="Select Octave">
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4" selected>4</option>
              <option value="5">5</option>
              <option value="6">6</option>
              <option value="7">7</option>
          </select>
      </div>
      <div class="control-group">
          <span class="control-label">Accidental:</span>
          <select id="editorAccidentalDropdown" class="dropdown-select" aria-label="Select Accidental">
              <option value="">♮ (Natural)</option>
              <option value="#"># (Sharp)</option>
              <option value="b">b (Flat)</option>
          </select>
      </div>
      <div class="control-group">
          <span class="control-label">Actions:</span>
          <button class="control-btn" aria-label="Move Note to Previous Measure" id="editorMoveToPrevMeasure">Move Left</button>
          <button class="control-btn" aria-label="Move Note to Next Measure" id="editorMoveToNextMeasure">Move Right</button>
          <button class="control-btn" aria-label="Remove Note" id="editorRemoveNote">Remove</button>
      </div>
  </div>
</div>

<script type="module">
  /*
  IMPORTANT: This <script> block should eventually be moved to musicEditorUI.js or an appropriate
  module. It's included here temporarily based on your request to consolidate.
  */

  // Import from your existing JS modules.
  // Ensure the paths are correct relative to where _newUI.html is served.
  import { getMeasures, addNoteToMeasure, removeNoteFromMeasure, updateNoteInMeasure, moveNoteBetweenMeasures } from '{{ url_for("static", filename="scoreWriter.js") }}';
  import { drawAll, enableScoreInteraction } from '{{ url_for("static", filename="scoreRenderer.js") }}';
  import { DURATIONS } from '{{ url_for("static", filename="note-data.js") }}';
  import { highlightSelectedMeasure, highlightSelectedNote, clearSelectedNoteHighlight } from '{{ url_for("static", filename="scoreHighlighter.js") }}';


  // ===================================================================
  // Internal State (from musicEditorUI.js)
  // ===================================================================

  let editorSelectedNoteId = null; // ID of the currently selected note
  let editorSelectedMeasureIndex = 0;
  let draggedElement = null; // For palette drag/drop
  let rightClickPos = null; // For context menu
  let currentSelectedNote = null; // For the mockup's visual note element tracking
  let selectedDuration = 'q'; // Default duration for new notes (matches DURATIONS key)

  // ===================================================================
  // Helper Functions (from musicEditorUI.js)
  // ===================================================================

  /**
   * Checks if a note name string represents a chord.
   * @param {string} noteName - The name property of a note object.
   * @returns {boolean} True if it's a chord, false otherwise.
   */
  function isChord(noteName) {
      console.log('isChord input:', noteName);
      const result = noteName && noteName.startsWith('(') && noteName.endsWith(')');
      console.log('isChord output:', result);
      return result;
  }

  /**
   * Parses a chord string into an array of individual note names.
   * e.g., "(C4 E4 G4)" becomes ["C4", "E4", "G4"]
   * @param {string} chordString - The chord name string.
   * @returns {Array<string>} An array of individual note name strings.
   */
  function parseChord(chordString) {
      console.log('parseChord input:', chordString);
      if (!isChord(chordString)) {
          console.warn('parseChord received non-chord string:', chordString);
          return [chordString]; // Return as a single note if not a chord format
      }
      const notes = chordString.substring(1, chordString.length - 1).split(' ').filter(Boolean);
      console.log('parseChord output:', notes);
      return notes;
  }

  /**
   * Formats an array of individual note names back into a chord string.
   * e.g., ["C4", "E4", "G4"] becomes "(C4 E4 G4)"
   * @param {Array<string>} noteArray - An array of individual note name strings.
   * @returns {string} The formatted chord string.
   */
  function formatChord(noteArray) {
      console.log('formatChord input:', noteArray);
      if (!Array.isArray(noteArray) || noteArray.length === 0) {
          return '';
      }
      const uniqueNotes = [...new Set(noteArray)].sort();
      const result = uniqueNotes.length > 1 ? `(${uniqueNotes.join(' ')})` : uniqueNotes[0];
      console.log('formatChord output:', result);
      return result;
  }

  /**
   * Parses a single note name (e.g., "C#4") into its components.
   * @param {string} noteName - The full note name.
   * @returns {{letter: string, accidental: string, octave: string}}
   */
  function parseSingleNoteName(noteName) {
      console.log('parseSingleNoteName input:', noteName);
      if (!noteName) return { letter: 'C', accidental: '', octave: '4' };
      const match = noteName.match(/^([A-G])([#b]?)([0-9]?)$/i);
      if (match) {
          const result = {
              letter: match[1].toUpperCase(),
              accidental: match[2] || '',
              octave: match[3] || '',
          };
          console.log('parseSingleNoteName output:', result);
          return result;
      }
      console.warn(`Could not fully parse note name: ${noteName}`);
      // Fallback for malformed note names, try to extract basic parts
      const letter = noteName.charAt(0).toUpperCase();
      const accidentalMatch = noteName.match(/[#b]/);
      const accidental = accidentalMatch ? accidentalMatch[0] : '';
      const octaveMatch = noteName.match(/[0-9]+/);
      const octave = octaveMatch ? octaveMatch[0] : '';

      const result = { letter, accidental, octave };
      console.log('parseSingleNoteName fallback output:', result);
      return result;
  }

  // ===================================================================
  // UI Rendering Functions (adapted from musicEditorUI.js and mockup)
  // ===================================================================

  /**
   * Renders the editor UI and updates the score's visual highlights.
   */
  function renderNoteEditBox() {
      console.log('renderNoteEditBox called. Current selected measure:', editorSelectedMeasureIndex, 'note ID:', editorSelectedNoteId);
      const measures = getMeasures();

      if (editorSelectedMeasureIndex >= measures.length) {
          editorSelectedMeasureIndex = Math.max(0, measures.length - 1);
      }

      const currentMeasure = measures[editorSelectedMeasureIndex] || [];

      // --- Update Measure Navigation UI (New UI's elements) ---
      const measureNumberInput = document.getElementById('editorNumberInput');
      if (measureNumberInput) {
          measureNumberInput.value = editorSelectedMeasureIndex + 1;
          // You may want to dynamically set max based on actual measure count
          // measureNumberInput.max = measures.length > 0 ? measures.length : 1;
      }
      document.getElementById('editorPrevBtn').disabled = editorSelectedMeasureIndex <= 0;
      document.getElementById('editorNextBtn').disabled = false;

      // --- Update OLD Editor UI (The original editor parts now moved into side-panel) ---
      // This block needs to be updated to target the 'Original' IDs
      const originalMeasureNumberInput = document.getElementById('editorNumberInputOriginal');
      if (originalMeasureNumberInput) {
          originalMeasureNumberInput.value = editorSelectedMeasureIndex + 1;
          originalMeasureNumberInput.max = measures.length > 0 ? measures.length : 1;
      }
      document.getElementById('editorPrevBtnOriginal').disabled = editorSelectedMeasureIndex <= 0;
      document.getElementById('editorNextBtnOriginal').disabled = false;


      const originalTrebleNotesContainer = document.getElementById('editorTrebleNotesContainer');
      const originalBassNotesContainer = document.getElementById('editorBassNotesContainer');
      if (originalTrebleNotesContainer && originalBassNotesContainer) {
          originalTrebleNotesContainer.innerHTML = '';
          originalBassNotesContainer.innerHTML = '';

          const createAddButton = (clef, originalIndex) => {
              const btn = document.createElement('button');
              btn.className = 'control-button add-note-initial';
              btn.dataset.originalIndex = originalIndex;
              btn.dataset.clef = clef;
              btn.textContent = '+';
              return btn;
          };

          const createNoteButton = (note) => {
              const btn = document.createElement('button');
              btn.className = `control-button note-select note-duration-${note.duration.replace('.', 'dot')}`;
              btn.dataset.noteId = note.id; // Use note.id for identification
              btn.dataset.clef = note.clef;

              btn.textContent = note.isRest ? "Rest" : (isChord(note.name) ? `Chord (${parseChord(note.name).length})` : note.name);

              if (note.id === editorSelectedNoteId) {
                  btn.classList.add('active-note-select');
              }
              return btn;
          };

          const addInitialButtonToContainer = (container, clef) => {
              const wrapper = document.createElement('div');
              wrapper.className = 'flex-items-center-gap-1';
              wrapper.appendChild(createAddButton(clef, -1));
              container.appendChild(wrapper);
          };

          addInitialButtonToContainer(originalTrebleNotesContainer, 'treble');
          addInitialButtonToContainer(originalBassNotesContainer, 'bass');

          currentMeasure.forEach((note, noteIndex) => {
              const container = note.clef === 'treble' ? originalTrebleNotesContainer : originalBassNotesContainer;
              const noteWrapper = document.createElement('div');
              noteWrapper.className = 'flex-items-center-gap-1';

              noteWrapper.appendChild(createNoteButton(note));
              noteWrapper.appendChild(createAddButton(note.clef, noteIndex));

              container.appendChild(noteWrapper);
          });
      }
      // --- END OLD Editor UI Update ---


      // --- Update Expanded Editor (New Floating/Dockable Panel) ---
      const editorExpandedEditor = document.getElementById('editingPanel'); // This is the new panel
      const originalExpandedEditor = document.getElementById('editorExpandedEditorOriginal'); // The old hidden panel
      const singleNoteControls = editorExpandedEditor.querySelector('#singleNoteControls');
      const chordNotesEditor = editorExpandedEditor.querySelector('#chordNotesEditor');
      const chordNotesContainer = editorExpandedEditor.querySelector('#chordNotesContainer');

      const selectedNote = editorSelectedNoteId !== null
          ? currentMeasure.find(note => note.id === editorSelectedNoteId)
          : null;

      if (selectedNote) {
          editorExpandedEditor.classList.add('visible'); // Show the new panel
          originalExpandedEditor.classList.add('hidden'); // Hide the old panel
          positionElementSafely(editorExpandedEditor, document.getElementById('newUIRenderScore')); // Position relative to score

          // Update panel content - NEW UI
          document.getElementById('editorSelectedNoteDisplay').value = selectedNote.isRest ? "Rest" : (isChord(selectedNote.name) ? `Chord` : selectedNote.name);

          // Update clef button text (new UI)
          document.getElementById('editorToggleClef').textContent = selectedNote.clef === 'treble' ? 'Treble' : 'Bass';


          const isSelectedNoteRest = selectedNote.isRest;
          const isSelectedNoteChord = isChord(selectedNote.name);

          // Hide/Show Note/Chord/Rest controls in new panel
          const noteTypeBtns = editorExpandedEditor.querySelectorAll('.control-group:nth-child(3) .control-btn');
          noteTypeBtns.forEach(btn => btn.classList.remove('active'));
          if (isSelectedNoteRest) {
              editorExpandedEditor.querySelector('[data-type="rest"]').classList.add('active');
              // Hide pitch/accidental/octave for rests in new UI
              editorExpandedEditor.querySelector('.control-group:nth-child(1)').style.display = 'none'; // Pitch
              editorExpandedEditor.querySelector('#editorOctaveDropdown').closest('.control-group').style.display = 'none'; // Octave
              editorExpandedEditor.querySelector('#editorAccidentalDropdown').closest('.control-group').style.display = 'none'; // Accidental

          } else if (isSelectedNoteChord) {
              editorExpandedEditor.querySelector('[data-type="chord"]').classList.add('active');
              // Hide pitch/accidental/octave for chords (they have their own editor)
              editorExpandedEditor.querySelector('.control-group:nth-child(1)').style.display = 'none'; // Pitch
              editorExpandedEditor.querySelector('#editorOctaveDropdown').closest('.control-group').style.display = 'none'; // Octave
              editorExpandedEditor.querySelector('#editorAccidentalDropdown').closest('.control-group').style.display = 'none'; // Accidental

              // Show chord editor (new UI) - this part assumes you will dynamically build it within editingPanel
              // For now, it will be blank if not implemented.
          } else { // Single note
              editorExpandedEditor.querySelector('[data-type="note"]').classList.add('active');
              // Show pitch/accidental/octave for single notes
              editorExpandedEditor.querySelector('.control-group:nth-child(1)').style.display = 'flex'; // Pitch
              editorExpandedEditor.querySelector('#editorOctaveDropdown').closest('.control-group').style.display = 'flex'; // Octave
              editorExpandedEditor.querySelector('#editorAccidentalDropdown').closest('.control-group').style.display = 'flex'; // Accidental

              const { letter, accidental, octave } = parseSingleNoteName(selectedNote.name);
              // Update new panel's pitch input
              document.getElementById('editorSelectedNoteDisplay').value = `${letter}${accidental}${octave}`;
              // Update new panel's octave/accidental dropdowns
              document.getElementById('editorOctaveDropdown').value = octave;
              document.getElementById('editorAccidentalDropdown').value = accidental || ''; // Use empty string for natural
          }

          // Update duration buttons in new panel
          const durationBtns = editorExpandedEditor.querySelectorAll('.control-group:nth-child(2) .control-btn');
          durationBtns.forEach(btn => btn.classList.remove('active'));
          const currentDurationBtn = editorExpandedEditor.querySelector(`.control-group:nth-child(2) .control-btn[data-duration="${selectedNote.duration}"]`);
          if (currentDurationBtn) {
              currentDurationBtn.classList.add('active');
          }

      } else {
          editorExpandedEditor.classList.remove('visible'); // Hide the new panel
          originalExpandedEditor.classList.add('hidden'); // Ensure old panel is hidden
          editorSelectedNoteId = null;
      }

      // --- Update Old Expanded Editor (still required for musicEditorUI.js logic) ---
      // This is a duplication but keeps existing logic working for now.
      const originalSelectedNoteDisplay = document.getElementById('editorSelectedNoteDisplayOriginal');
      const originalSingleNoteControls = document.getElementById('singleNoteControls');
      const originalChordNotesEditor = document.getElementById('chordNotesEditor');
      const originalChordNotesContainer = document.getElementById('chordNotesContainer');

      if (selectedNote) {
          originalExpandedEditor.classList.remove('hidden'); // Show the old panel's container (even if new one is active)
          originalSelectedNoteDisplay.textContent = selectedNote.isRest ? "Rest" : (isChord(selectedNote.name) ? `Chord (${parseChord(selectedNote.name).length})` : selectedNote.name);
          document.getElementById('editorToggleClefOriginal').textContent = selectedNote.clef === 'treble' ? 'Treble' : 'Bass';
          document.getElementById('editorDurationDropdownOriginal').value = selectedNote.duration;

          if (selectedNote.isRest) {
              originalSingleNoteControls.classList.remove('hidden');
              originalChordNotesEditor.classList.add('hidden');
              document.getElementById('editorNoteLetter').value = 'R';
              document.getElementById('editorAccidentalDropdownOriginal').value = '';
              document.getElementById('editorOctaveDropdownOriginal').value = '';
              document.getElementById('editorNoteLetter').disabled = true;
              document.getElementById('editorAccidentalDropdownOriginal').disabled = true;
              document.getElementById('editorOctaveDropdownOriginal').disabled = true;
          } else if (isChord(selectedNote.name)) {
              originalSingleNoteControls.classList.add('hidden');
              originalChordNotesEditor.classList.remove('hidden');
              document.getElementById('editorNoteLetter').disabled = true;
              document.getElementById('editorAccidentalDropdownOriginal').disabled = true;
              document.getElementById('editorOctaveDropdownOriginal').disabled = true;

              originalChordNotesContainer.innerHTML = '';
              const individualChordNotes = parseChord(selectedNote.name);
              individualChordNotes.forEach((noteName, noteIndex) => {
                  const noteParts = parseSingleNoteName(noteName);
                  const noteDiv = document.createElement('div');
                  noteDiv.className = 'chord-note-item control-group';
                  noteDiv.innerHTML = `
                      <label>Note ${noteIndex + 1}:</label>
                      <select class="chord-note-letter" data-note-index="${noteIndex}">
                          <option value="C">C</option><option value="D">D</option><option value="E">E</option>
                          <option value="F">F</option><option value="G">G</option><option value="A">A</option>
                          <option value="B">B</option>
                      </select>
                      <select class="chord-note-accidental" data-note-index="${noteIndex}">
                          <option value="">None</option><option value="#">#</option><option value="b">b</option>
                      </select>
                      <select class="chord-note-octave" data-note-index="${noteIndex}">
                          <option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option><option value="6">6</option><option value="7">7</option>
                      </select>
                      <button class="remove-chord-note-btn" data-note-index="${noteIndex}">x</button>
                  `;
                  originalChordNotesContainer.appendChild(noteDiv);
                  noteDiv.querySelector('.chord-note-letter').value = noteParts.letter;
                  noteDiv.querySelector('.chord-note-accidental').value = noteParts.accidental;
                  noteDiv.querySelector('.chord-note-octave').value = noteParts.octave;
              });
          } else { // Single note
              originalSingleNoteControls.classList.remove('hidden');
              originalChordNotesEditor.classList.add('hidden');
              const { letter, accidental, octave } = parseSingleNoteName(selectedNote.name);
              document.getElementById('editorNoteLetter').value = letter;
              document.getElementById('editorAccidentalDropdownOriginal').value = accidental;
              document.getElementById('editorOctaveDropdownOriginal').value = octave;
              document.getElementById('editorNoteLetter').disabled = false;
              document.getElementById('editorAccidentalDropdownOriginal').disabled = false;
              document.getElementById('editorOctaveDropdownOriginal').disabled = false;
          }
      } else {
          originalExpandedEditor.classList.add('hidden');
          editorSelectedNoteId = null;
      }

      // --- Update Score Highlighting using Refactored Functions ---
      highlightSelectedMeasure(editorSelectedMeasureIndex);
      console.log("edit box rendered, highlighting measure");

      if (selectedNote) {
          highlightSelectedNote(editorSelectedMeasureIndex, selectedNote.clef, selectedNote.id);
      } else {
          clearSelectedNoteHighlight();
      }
      console.log('renderNoteEditBox completed.');
  }

  /**
   * Handles changing the current measure.
   * @param {number} newMeasureIndex - The index of the measure to switch to.
   */
  function changeMeasure(newMeasureIndex) {
      console.log('changeMeasure called with index:', newMeasureIndex);
      const measures = getMeasures();
      if (newMeasureIndex >= 0 && newMeasureIndex <= measures.length) {
          editorSelectedMeasureIndex = newMeasureIndex;
          editorSelectedNoteId = null; // Deselect any note when changing measure
          renderNoteEditBox();
          scrollToMeasure(editorSelectedMeasureIndex);
      }
      console.log('changeMeasure completed. New selected measure:', editorSelectedMeasureIndex);
  }

  // ===================================================================
  // Handlers for Direct Score Interaction (from musicEditorUI.js)
  // ===================================================================
  function handleEditorNoteSelectClick(measureIndex, clef, noteId) {
      console.log('handleEditorNoteSelectClick called with measure:', measureIndex, 'clef:', clef, 'noteId:', noteId);

      editorSelectedMeasureIndex = measureIndex; // Always update the selected measure

      if (noteId === null) {
          console.log('handleEditorNoteSelectClick: Click on empty space or measure background detected. Deselecting note.');
          editorSelectedNoteId = null;
          clearSelectedNoteHighlight();
          renderNoteEditBox();
          return;
      }

      const currentMeasureNotes = getMeasures()[measureIndex] || [];
      const foundNote = currentMeasureNotes.find(note => note.id === noteId);
      if (!foundNote || foundNote.clef !== clef) {
          console.warn(`handleEditorNoteSelectClick: Invalid or mismatched note data for ID ${noteId} in measure ${measureIndex}, clef ${clef}. Deselecting note.`);
          editorSelectedNoteId = null;
          clearSelectedNoteHighlight();
          renderNoteEditBox();
          return;
      }

      editorSelectedNoteId = (editorSelectedNoteId === noteId) ? null : noteId;
      console.log('Editor selected note ID:', editorSelectedNoteId);

      renderNoteEditBox();
  }

  /**
   * Handles a click event on a measure in the score display.
   * @param {number} measureIndex
   * @param {boolean} wasNoteClicked - True if the click originated from a note, false otherwise.
   */
  function handleMeasureClick(measureIndex, wasNoteClicked) {
      console.log('handleMeasureClick called with measure:', measureIndex, 'wasNoteClicked:', wasNoteClicked);
      if (!wasNoteClicked) {
          editorSelectedNoteId = null;
          clearSelectedNoteHighlight();
      }
      editorSelectedMeasureIndex = measureIndex;
      renderNoteEditBox();
      scrollToMeasure(measureIndex);
  }

  /**
   * Handles a click event on a note in the score display.
   * @param {number} measureIndex
   * @param {string} clef
   * @param {string} noteId
   */
  function handleNoteClick(measureIndex, clef, noteId) {
      console.log('handleNoteClick called with measure:', measureIndex, 'clef:', clef, 'noteId:', noteId);
      handleEditorNoteSelectClick(measureIndex, clef, noteId);
      scrollToMeasure(measureIndex);
  }

  // ===================================================================
  // Chord Editing Logic (from musicEditorUI.js)
  // ===================================================================

  /**
   * Updates a chord based on the values in the chord notes editor UI.
   */
  function updateChordFromUI() {
      console.log('updateChordFromUI called');
      const measures = getMeasures();
      const currentMeasure = measures[editorSelectedMeasureIndex];
      if (!currentMeasure || editorSelectedNoteId === null) {
          console.warn('No note selected or measure not found for chord update.');
          return;
      }

      const selectedNote = currentMeasure.find(note => note.id === editorSelectedNoteId);
      if (!selectedNote) {
          console.warn('Selected note not found for chord update by ID:', editorSelectedNoteId);
          return;
      }

      const chordNotes = [];
      const chordNoteItems = document.querySelectorAll('#chordNotesContainer .chord-note-item');
      let hasInvalidNotes = false;

      chordNoteItems.forEach(item => {
          const letter = item.querySelector('.chord-note-letter').value;
          const accidental = item.querySelector('.chord-note-accidental').value;
          const octave = item.querySelector('.chord-note-octave').value;
          if (letter && octave) {
              chordNotes.push(`${letter}${accidental}${octave}`);
          } else {
              hasInvalidNotes = true;
              console.warn('Invalid note component found in chord editor:', { letter, accidental, octave });
          }
      });

      if (hasInvalidNotes && chordNotes.length === 0) {
          console.error('Attempted to update chord with no valid notes, converting to rest.');
          updateNoteInMeasure(editorSelectedMeasureIndex, selectedNote.id, { isRest: true, name: "R" });
          renderNoteEditBox();
          return;
      }

      const newName = formatChord(chordNotes);

      if (chordNotes.length === 1 && isChord(selectedNote.name)) {
          console.log('Chord reduced to a single note, converting back to single note type.');
          updateNoteInMeasure(editorSelectedMeasureIndex, selectedNote.id, { name: chordNotes[0], isRest: false });
      } else if (chordNotes.length > 0) {
          updateNoteInMeasure(editorSelectedMeasureIndex, selectedNote.id, { name: newName, isRest: false });
      } else {
          console.log('All notes removed from chord, converting to rest.');
          updateNoteInMeasure(editorSelectedMeasureIndex, selectedNote.id, { isRest: true, name: "R" });
      }
      renderNoteEditBox();
  }

  /**
   * Adds a new note field to the chord editor UI.
   */
  function addNoteToChordUI() {
      console.log('addNoteToChordUI called');
      const measures = getMeasures();
      const currentMeasure = measures[editorSelectedMeasureIndex];
      if (!currentMeasure || editorSelectedNoteId === null) return;

      const selectedNote = currentMeasure.find(note => note.id === editorSelectedNoteId);
      if (!selectedNote) return;

      let currentChordNotes = isChord(selectedNote.name) ? parseChord(selectedNote.name) : [selectedNote.name];
      currentChordNotes.push('C4');

      updateNoteInMeasure(editorSelectedMeasureIndex, selectedNote.id, { name: formatChord(currentChordNotes), isRest: false });
      renderNoteEditBox();
      console.log('addNoteToChordUI completed. New chord notes:', currentChordNotes);
  }

  /**
   * Removes a note field from the chord editor UI and updates the chord data.
   * @param {number} noteIndexToRemove - The index of the note within the chord's array to remove.
   */
  function removeNoteFromChordUI(noteIndexToRemove) {
      console.log('removeNoteFromChordUI called with index:', noteIndexToRemove);
      const measures = getMeasures();
      const currentMeasure = measures[editorSelectedMeasureIndex];
      if (!currentMeasure || editorSelectedNoteId === null) return;

      const selectedNote = currentMeasure.find(note => note.id === editorSelectedNoteId);
      if (!selectedNote) return;

      let currentChordNotes = isChord(selectedNote.name) ? parseChord(selectedNote.name) : [selectedNote.name];

      if (currentChordNotes.length > 1) {
          currentChordNotes.splice(noteIndexToRemove, 1);
          updateNoteInMeasure(editorSelectedMeasureIndex, selectedNote.id, { name: formatChord(currentChordNotes) });
      } else {
          console.log('Last note of chord removed, converting to rest.');
          updateNoteInMeasure(editorSelectedMeasureIndex, selectedNote.id, { isRest: true, name: "R" });
      }
      renderNoteEditBox();
      console.log('removeNoteFromChordUI completed. Remaining chord notes:', currentChordNotes);
  }

  // ===================================================================
  // New UI Specific Functions (from mockup script, adapted)
  // ===================================================================

  function setupPaletteDrag() {
      const paletteNotes = document.querySelectorAll('.palette-note');

      paletteNotes.forEach(note => {
          if (['quarter', 'eighth', 'half', 'whole', 'rest'].includes(note.dataset.type)) {
              note.draggable = true;
          }
          note.addEventListener('click', function(e) {
              if (['quarter', 'eighth', 'half', 'whole'].includes(this.dataset.type)) {
                  selectDuration(this.dataset.type);
                  e.preventDefault();
              }
          });
          note.addEventListener('dragstart', function(e) {
              draggedElement = this;
              e.dataTransfer.setData('text/plain', this.dataset.type);
              console.log('Drag started:', this.dataset.type);
          });
          note.addEventListener('dragend', function() {
              draggedElement = null;
              document.getElementById('ghost-note').classList.remove('visible');
          });
      });
  }

  function setupStaffInteractions() {
      // This function needs to interact with the actual rendered VexFlow score, not the mockup's staff divs.
      // The event listeners should be attached by scoreRenderer.js using enableScoreInteraction.
      // The "createNote" function below will be called via drag/drop or context menu, and will use your data model.

      // The staff divs from the mockup HTML (if you keep them) will not automatically interact with VexFlow.
      // For actual note creation on the score, rely on handleMeasureClick/handleNoteClick events exposed by scoreRenderer.
      console.warn("setupStaffInteractions from mockup script: This part is for visual mockup, actual score interaction is via enableScoreInteraction in scoreRenderer.");
  }

  function setupContextMenu() {
      const menu = document.getElementById('contextMenu');
      const scoreContainer = document.querySelector('.score-container'); // Or the actual score wrap

      if (!menu || !scoreContainer) {
          console.warn("Context menu or score container not found for setupContextMenu.");
          return;
      }

      // Context menu for the score area (e.g., right click on general score space)
      scoreContainer.addEventListener('contextmenu', function(e) {
          e.preventDefault();
          // Store position relative to the document
          rightClickPos = {
              x: e.clientX,
              y: e.clientY
          };
          menu.style.left = e.clientX + 'px';
          menu.style.top = e.clientY + 'px';
          menu.classList.add('visible');
          console.log('Right clicked on score container');
      });

      const menuItems = document.querySelectorAll('#contextMenu .context-menu-item');
      menuItems.forEach(item => {
          item.addEventListener('click', function() {
              if (rightClickPos) {
                  // Need to determine the target measure/clef here
                  // This is complex as it requires mapping screen coordinates to staff positions in VexFlow.
                  // For now, we'll just log and hide. Actual creation logic needs scoreRenderer context.
                  console.log('Context menu item clicked:', this.dataset.type, 'at', rightClickPos);
                  // Placeholder: add a note to current selected measure for simplicity
                  const newNoteType = this.dataset.type;
                  const newClef = 'treble'; // Default clef for context menu
                  const newNoteData = { name: "C4", clef: newClef, duration: newNoteType.includes('rest') ? 'q' : newNoteType, isRest: newNoteType.includes('rest') };
                  if (newNoteType.includes('chord')) { // Example: turn into a chord
                      newNoteData.name = "(C4 E4 G4)";
                      newNoteData.isRest = false;
                  }
                  addNoteToMeasure(editorSelectedMeasureIndex, newNoteData, -1); // Add at end of measure
                  drawAll(getMeasures()); // Redraw the score
                  renderNoteEditBox(); // Refresh editor UI
              }
              hideContextMenu();
          });
      });

      document.addEventListener('click', function(e) {
          if (!e.target.closest('.context-menu')) {
              hideContextMenu();
          }
      });
  }


  function positionElementSafely(element, anchorElement) {
      const elementRect = element.getBoundingClientRect();
      const anchorRect = anchorElement.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      let x = anchorRect.left;
      let y = anchorRect.bottom + 10;

      if (x + elementRect.width > viewportWidth) {
          x = viewportWidth - elementRect.width - 20;
      }
      if (x < 20) x = 20;

      if (y + elementRect.height > viewportHeight - 20) {
          y = anchorRect.top - elementRect.height - 10;
          if (y < 20) y = 20;
      }

      element.style.left = x + 'px';
      element.style.top = y + 'px';
  }

  function setupNoteTooltips() {
      // This function will primarily handle the editingPanel interactions.
      // It relies on currentSelectedNote being set by handleNoteClick from scoreRenderer.
      const editingPanel = document.getElementById('editingPanel');
      if (!editingPanel) {
          console.error("Editing panel not found for setupNoteTooltips!");
          return;
      }

      const panelCloseBtn = editingPanel.querySelector('.panel-close');
      const panelDockBtn = editingPanel.querySelector('.panel-dock');

      // Note: The original mockup had document.querySelectorAll('.note') here.
      // In a VexFlow system, notes are SVG/Canvas elements, not separate divs with class 'note'.
      // Interaction with VexFlow notes should come from scoreRenderer's enableScoreInteraction.
      // So, we'll ensure showNoteEditor is called via handleNoteClick.

      if (panelCloseBtn) panelCloseBtn.addEventListener('click', () => { hideNoteEditor(); });
      if (panelDockBtn) panelDockBtn.addEventListener('click', () => { toggleDockPanel(); });

      document.addEventListener('click', (e) => {
          if (!editingPanel.contains(e.target) && !e.target.closest('.vf-note') && !e.target.closest('.palette-note')) { // Check VexFlow notes
              hideNoteEditor();
          }
      });

      document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
              hideNoteEditor();
          }
      });

      // Duration buttons (New UI)
      editingPanel.querySelectorAll('.control-group:nth-child(2) .control-btn').forEach(btn => {
          btn.addEventListener('click', function() {
              editingPanel.querySelectorAll('.control-group:nth-child(2) .control-btn').forEach(b => b.classList.remove('active'));
              this.classList.add('active');
              selectedDuration = this.dataset.duration; // Update module-level selectedDuration

              if (currentSelectedNote) { // If a note is selected in the score
                  // Update the selected note's duration in your data model
                  updateNoteInMeasure(editorSelectedMeasureIndex, editorSelectedNoteId, { duration: selectedDuration });
                  drawAll(getMeasures()); // Redraw score
              }
          });
      });

      // Type buttons (Note, Chord, Rest) (New UI)
      editingPanel.querySelectorAll('.control-group:nth-child(3) .control-btn').forEach(btn => {
          btn.addEventListener('click', function() {
              editingPanel.querySelectorAll('.control-group:nth-child(3) .control-btn').forEach(b => b.classList.remove('active'));
              this.classList.add('active');
              const newType = this.dataset.type;

              if (currentSelectedNote && editorSelectedNoteId) {
                  const selectedNoteData = getMeasures()[editorSelectedMeasureIndex]?.find(n => n.id === editorSelectedNoteId);
                  if (!selectedNoteData) return;

                  if (newType === 'rest') {
                      updateNoteInMeasure(editorSelectedMeasureIndex, editorSelectedNoteId, { isRest: true, name: "R" });
                  } else if (newType === 'note') {
                      // Convert to single note from rest or chord
                      if (selectedNoteData.isRest) {
                          updateNoteInMeasure(editorSelectedMeasureIndex, editorSelectedNoteId, { isRest: false, name: "C4" });
                      } else if (isChord(selectedNoteData.name)) {
                          const firstNote = parseChord(selectedNoteData.name)[0] || "C4";
                          updateNoteInMeasure(editorSelectedMeasureIndex, editorSelectedNoteId, { isRest: false, name: firstNote });
                      }
                  } else if (newType === 'chord') {
                      // Convert to chord from single note or rest
                      if (selectedNoteData.isRest) {
                          updateNoteInMeasure(editorSelectedMeasureIndex, editorSelectedNoteId, { isRest: false, name: "(C4 E4 G4)" });
                      } else if (!isChord(selectedNoteData.name)) {
                          updateNoteInMeasure(editorSelectedMeasureIndex, editorSelectedNoteId, { isRest: false, name: `(${selectedNoteData.name} E4 G4)` });
                      }
                  }
                  renderNoteEditBox(); // Re-render to update UI for type change and score
                  drawAll(getMeasures()); // Redraw score
              }
          });
      });

      setupSidePanelButtons(); // Call the mockup's side panel button setup

      // Setup pitch input change listener (New UI)
      const newUIPitchInput = document.getElementById('editorSelectedNoteDisplay'); // This is the input in the new UI
      if (newUIPitchInput) {
          newUIPitchInput.addEventListener('change', function() {
              if (editorSelectedNoteId && !currentSelectedNote.isRest) { // Only update if a note is selected and not a rest
                  const newPitchValue = this.value;
                  updateNoteInMeasure(editorSelectedMeasureIndex, editorSelectedNoteId, { name: newPitchValue });
                  drawAll(getMeasures()); // Redraw score
              }
          });
          newUIPitchInput.addEventListener('keydown', function(e) {
              if (e.key === 'Enter') {
                  this.blur();
              }
          });
      }

      // Setup Accidental/Octave dropdowns (New UI)
      const editorAccidentalDropdown = document.getElementById('editorAccidentalDropdown');
      const editorOctaveDropdown = document.getElementById('editorOctaveDropdown');
      if (editorAccidentalDropdown) {
          editorAccidentalDropdown.addEventListener('change', function() {
              if (editorSelectedNoteId && !currentSelectedNote.isRest) {
                  const selectedNoteData = getMeasures()[editorSelectedMeasureIndex]?.find(n => n.id === editorSelectedNoteId);
                  if (selectedNoteData && !isChord(selectedNoteData.name)) {
                      const { letter, octave } = parseSingleNoteName(selectedNoteData.name);
                      const newAccidental = this.value;
                      updateNoteInMeasure(editorSelectedMeasureIndex, editorSelectedNoteId, { name: `${letter}${newAccidental}${octave}` });
                      drawAll(getMeasures());
                  }
              }
          });
      }
      if (editorOctaveDropdown) {
          editorOctaveDropdown.addEventListener('change', function() {
              if (editorSelectedNoteId && !currentSelectedNote.isRest) {
                  const selectedNoteData = getMeasures()[editorSelectedMeasureIndex]?.find(n => n.id === editorSelectedNoteId);
                  if (selectedNoteData && !isChord(selectedNoteData.name)) {
                      const { letter, accidental } = parseSingleNoteName(selectedNoteData.name);
                      const newOctave = this.value;
                      updateNoteInMeasure(editorSelectedMeasureIndex, editorSelectedNoteId, { name: `${letter}${accidental}${newOctave}` });
                      drawAll(getMeasures());
                  }
              }
          });
      }

      // Pitch Up/Down buttons (New UI) - Need to implement pitch change logic
      const pitchUpBtn = editingPanel.querySelector('[aria-label="Pitch Up"]');
      const pitchDownBtn = editingPanel.querySelector('[aria-label="Pitch Down"]');

      if (pitchUpBtn) {
          pitchUpBtn.addEventListener('click', () => {
              if (editorSelectedNoteId && !currentSelectedNote.isRest) {
                  const selectedNoteData = getMeasures()[editorSelectedMeasureIndex]?.find(n => n.id === editorSelectedNoteId);
                  if (selectedNoteData) {
                      // This is a placeholder. You'll need actual music theory logic
                      // to get the next higher note. Tonal.js might help.
                      let currentPitch = selectedNoteData.name;
                      let nextPitch = currentPitch; // Placeholder for actual logic
                      console.log(`Pitch Up clicked for ${currentPitch}`);

                      if (!isChord(currentPitch)) {
                          // Example using Tonal for single notes:
                          try {
                              const { Midi } = Tonal;
                              let midi = Midi.toMidi(currentPitch);
                              if (midi !== null) {
                                  midi++; // Increment MIDI note
                                  nextPitch = Midi.toNote(midi);
                              }
                          } catch (e) {
                              console.error("Error using Tonal for pitch up:", e);
                          }
                      } else {
                          // For chords, you might want to transpose all notes in the chord
                          // For simplicity here, we'll just log
                          console.warn("Pitch Up on chords not fully implemented yet.");
                      }

                      if (nextPitch !== currentPitch) {
                          updateNoteInMeasure(editorSelectedMeasureIndex, editorSelectedNoteId, { name: nextPitch });
                          drawAll(getMeasures());
                          renderNoteEditBox(); // Update the editor display
                      }
                  }
              }
          });
      }

      if (pitchDownBtn) {
          pitchDownBtn.addEventListener('click', () => {
              if (editorSelectedNoteId && !currentSelectedNote.isRest) {
                  const selectedNoteData = getMeasures()[editorSelectedMeasureIndex]?.find(n => n.id === editorSelectedNoteId);
                  if (selectedNoteData) {
                      let currentPitch = selectedNoteData.name;
                      let nextPitch = currentPitch; // Placeholder for actual logic
                      console.log(`Pitch Down clicked for ${currentPitch}`);

                      if (!isChord(currentPitch)) {
                          try {
                              const { Midi } = Tonal;
                              let midi = Midi.toMidi(currentPitch);
                              if (midi !== null && midi > 0) { // Ensure not going below MIDI 0
                                  midi--; // Decrement MIDI note
                                  nextPitch = Midi.toNote(midi);
                              }
                          } catch (e) {
                              console.error("Error using Tonal for pitch down:", e);
                          }
                      } else {
                          console.warn("Pitch Down on chords not fully implemented yet.");
                      }

                      if (nextPitch !== currentPitch) {
                          updateNoteInMeasure(editorSelectedMeasureIndex, editorSelectedNoteId, { name: nextPitch });
                          drawAll(getMeasures());
                          renderNoteEditBox(); // Update the editor display
                      }
                  }
              }
          });
      }
  }

  function showNoteEditor(noteElement) {
      // This 'noteElement' refers to a *visual* note div created by the mockup's JS,
      // not necessarily a VexFlow-rendered note. We need to find the actual note data.
      // This function will be called by `handleNoteClick` (from scoreRenderer) for VexFlow notes.

      const editingPanel = document.getElementById('editingPanel');
      if (!editingPanel) return;

      // Clear previous selection visually (mockup's notes)
      document.querySelectorAll('.note.selected').forEach(n => n.classList.remove('selected'));

      // If 'noteElement' is one of the mockup's sample notes:
      if (noteElement.classList.contains('note') && noteElement.dataset.pitch) {
           // For the mockup's hardcoded notes, we simulate selection and data
          currentSelectedNote = { // Create a dummy object to match expected structure
              id: 'mock-note-' + Math.random().toString(36).substring(2, 9),
              name: noteElement.dataset.pitch,
              clef: noteElement.closest('.staff')?.dataset.clef || 'treble',
              duration: 'q', // Assume quarter for mockup notes
              isRest: false
          };
          editorSelectedNoteId = currentSelectedNote.id;
          // Apply mockup selection style
          noteElement.classList.add('selected');
      } else {
          // This path is for when a VexFlow note is clicked via scoreRenderer
          // currentSelectedNote will be the VexFlow element, and editorSelectedNoteId is the real ID.
          const measures = getMeasures();
          const selectedNoteData = measures[editorSelectedMeasureIndex]?.find(note => note.id === editorSelectedNoteId);

          if (!selectedNoteData) {
              console.warn("No actual note data found for selected visual element.");
              hideNoteEditor();
              return;
          }
          currentSelectedNote = selectedNoteData; // Set currentSelectedNote to the data object
      }

      // Position panel relative to the score element for now, or the specific note if possible
      positionElementSafely(editingPanel, document.getElementById('newUIRenderScoreWrap')); // or a more specific element if you have a way to find its visual position


      // Update panel content - NEW UI
      const pitchDisplayInput = document.getElementById('editorSelectedNoteDisplay');
      if (pitchDisplayInput) {
          pitchDisplayInput.value = currentSelectedNote.name || 'C4'; // Set input value
      }

      // Update other controls based on currentSelectedNote's actual data
      renderNoteEditBox(); // This function already updates all relevant controls

      editingPanel.classList.add('visible');
      console.log('Note editor opened for:', currentSelectedNote.name, '(ID:', editorSelectedNoteId, ')');
  }


  function hideNoteEditor() {
      const editingPanel = document.getElementById('editingPanel');
      editingPanel.classList.remove('visible');

      if (currentSelectedNote) {
          // Remove selection from mockup notes
          document.querySelectorAll('.note.selected').forEach(n => n.classList.remove('selected'));
          // Clear VexFlow selection via highlighter
          clearSelectedNoteHighlight();
          currentSelectedNote = null;
          editorSelectedNoteId = null;
      }
  }

  function createNote(staff, x, y, type) {
      // This createNote is from the mockup and visually creates a div.
      // For actual functionality, we need to add to your data model and redraw.
      console.log("Mockup createNote called. Translating to data model addition.");

      // Determine target clef based on staff's data-clef attribute
      const targetClef = staff.dataset.clef || 'treble';

      // Determine a reasonable default pitch based on y position if possible, or a default
      let defaultPitch = 'C4'; // Placeholder. Advanced would map y to pitch.

      // Determine type based on input and selectedDuration
      let isRest = type.includes('rest');
      let isChordType = type.includes('major') || type.includes('minor');
      let durationKey = type.split('-').pop(); // e.g., 'quarter' from 'major-quarter' or 'rest-quarter'

      const noteData = {
          name: isRest ? "R" : (isChordType ? "(C4 E4 G4)" : defaultPitch),
          clef: targetClef,
          duration: durationKey,
          isRest: isRest
      };

      // Add to data model
      const addedNoteId = addNoteToMeasure(editorSelectedMeasureIndex, noteData, -1); // Add to end of current measure

      // Set the newly added note as selected
      editorSelectedNoteId = addedNoteId;
      // Re-render all scores
      drawAll(getMeasures());
      renderNoteEditBox(); // Update the editor UI to show the new note's properties

      console.log('Note added to data model:', noteData, 'ID:', addedNoteId);
  }


  function hideContextMenu() {
      document.getElementById('contextMenu').classList.remove('visible');
      rightClickPos = null;
  }

  function toggleDockPanel() {
      const editingPanel = document.getElementById('editingPanel');
      const dockedContainer = document.getElementById('dockedEditingContainer');
      const panelDockBtn = editingPanel.querySelector('.panel-dock');

      if (editingPanel.classList.contains('docked')) {
          editingPanel.classList.remove('docked');
          dockedContainer.style.display = 'none';

          // IMPORTANT: Move panel back to its original parent (score-container in new UI)
          document.querySelector('.score-container').appendChild(editingPanel);

          panelDockBtn.innerHTML = '◀';
          panelDockBtn.setAttribute('aria-label', 'Dock to sidebar');

          if (currentSelectedNote) {
              // If currentSelectedNote is a VexFlow note, you'd need its rendered position.
              // For now, position relative to scorewrap.
              positionElementSafely(editingPanel, document.getElementById('newUIRenderScoreWrap'));
          }

          console.log('Panel undocked');
      } else {
          editingPanel.classList.add('docked');
          dockedContainer.style.display = 'block';

          panelDockBtn.innerHTML = '↗';
          panelDockBtn.setAttribute('aria-label', 'Undock from sidebar');

          // Move panel to docked container in the side panel
          dockedContainer.appendChild(editingPanel);

          console.log('Panel docked');
      }
  }

  function setupSidePanelButtons() {
      const sideBtns = document.querySelectorAll('.side-btn');

      sideBtns.forEach(btn => {
          btn.addEventListener('click', function() {
              const text = this.textContent.trim();
              console.log('Side panel button clicked:', text);

              const currentMeasure = getMeasures()[editorSelectedMeasureIndex];
              if (!currentMeasure) {
                  console.warn("No current measure to add notes/chords/rests to.");
                  return;
              }

              let newNoteData = {};
              let clef = 'treble'; // Default to treble unless bass is implied by button text

              if (text.includes('Bass')) {
                  clef = 'bass';
              }

              if (text.includes('♩ Treble') || text.includes('♩ Bass')) {
                  const noteName = prompt(`Enter note for ${clef} staff (e.g., C4, F#5, Bb3):`);
                  if (noteName) {
                      newNoteData = { name: noteName, clef: clef, duration: selectedDuration, isRest: false };
                  } else return;
              } else if (text.includes('♩♩♩ Treble') || text.includes('♩♩♩ Bass')) {
                  const chordName = prompt(`Enter chord for ${clef} staff (e.g., C4 E4 G4 for C major):`);
                  if (chordName) {
                      newNoteData = { name: `(${chordName})`, clef: clef, duration: selectedDuration, isRest: false };
                  } else return;
              } else if (text.includes('𝄽 Add Rest')) {
                  newNoteData = { name: "R", clef: clef, duration: selectedDuration, isRest: true };
              } else if (text.includes('Fill Measure')) {
                  // This is more complex: needs to calculate remaining duration and add rests
                  console.log('Fill measure with rests - functionality to be implemented.');
                  return; // Skip for now
              }

              if (Object.keys(newNoteData).length > 0) {
                  const addedNoteId = addNoteToMeasure(editorSelectedMeasureIndex, newNoteData, -1); // Add to end
                  editorSelectedNoteId = addedNoteId;
                  drawAll(getMeasures()); // Re-render the score
                  renderNoteEditBox(); // Update the editor UI
              }
          });
      });
  }

  function selectDuration(duration) {
      selectedDuration = duration;

      // Update visual state of palette buttons
      document.querySelectorAll('.palette-note').forEach(btn => {
          btn.classList.remove('active');
      });

      const activeBtn = document.querySelector(`.palette-note[data-type="${duration}"]`);
      if (activeBtn) {
          activeBtn.classList.add('active');
      }

      console.log('Duration selected:', duration);
  }

  function setDefaultDuration() {
      selectDuration('q'); // Use 'q' for quarter, matching DURATIONS key
  }


  // ===================================================================
  // Main Initialization for this consolidated UI
  // ===================================================================

  function initializeConsolidatedEditorUI() {
      console.log("initializeConsolidatedEditorUI called. Starting setup.");

      // Old UI: Measure Navigation
      document.getElementById('editorPrevBtnOriginal')?.addEventListener('click', (event) => { event.preventDefault(); changeMeasure(editorSelectedMeasureIndex - 1); });
      document.getElementById('editorNextBtnOriginal')?.addEventListener('click', (event) => { event.preventDefault(); changeMeasure(editorSelectedMeasureIndex + 1); });
      document.getElementById('editorNumberInputOriginal')?.addEventListener('change', (event) => {
          const newMeasureNum = parseInt(event.target.value, 10);
          if (!isNaN(newMeasureNum) && newMeasureNum >= 1) {
              changeMeasure(newMeasureNum - 1);
          }
      });

      // Old UI: Note Actions (initial view) - dynamic buttons
      const originalEditorContainer = document.getElementById('editorContainer'); // Parent for delegation
      if (originalEditorContainer) {
          originalEditorContainer.addEventListener('click', (event) => {
              const target = event.target;
              if (target.classList.contains('add-note-initial')) {
                  const insertAfterLinearIndex = parseInt(target.dataset.originalIndex, 10);
                  const newClef = target.dataset.clef;
                  const newNote = { name: "C4", clef: newClef, duration: selectedDuration, isRest: false };
                  const addedNoteId = addNoteToMeasure(editorSelectedMeasureIndex, newNote, insertAfterLinearIndex + 1);
                  editorSelectedNoteId = addedNoteId;
                  drawAll(getMeasures()); // Redraw score
                  renderNoteEditBox();
              }
              if (target.classList.contains('note-select')) {
                  const noteId = target.dataset.noteId;
                  const clef = target.dataset.clef;
                  handleEditorNoteSelectClick(editorSelectedMeasureIndex, clef, noteId);
              }
          });

          originalEditorContainer.addEventListener('change', (event) => {
              const target = event.target;
              const measures = getMeasures();
              const currentMeasure = measures[editorSelectedMeasureIndex];
              if (!currentMeasure || editorSelectedNoteId === null) {
                  console.warn('No note selected for change event in old UI controls.');
                  return;
              }

              const selectedNote = currentMeasure.find(note => note.id === editorSelectedNoteId);
              if (!selectedNote) {
                  console.warn('Selected note not found by ID for change event in old UI:', editorSelectedNoteId);
                  return;
              }

              console.log('Change event on old editor UI. Target ID:', target.id, 'Value:', target.value);

              if (selectedNote.isRest) {
                  if (target.id === 'editorDurationDropdownOriginal') {
                      updateNoteInMeasure(editorSelectedMeasureIndex, selectedNote.id, { duration: target.value });
                  }
                  drawAll(getMeasures());
                  renderNoteEditBox();
                  return;
              }

              if (target.id === 'editorNoteLetter' ||
                  target.id === 'editorAccidentalDropdownOriginal' ||
                  target.id === 'editorOctaveDropdownOriginal') {

                  let newLetter = document.getElementById('editorNoteLetter').value;
                  let newAccidental = document.getElementById('editorAccidentalDropdownOriginal').value;
                  let newOctave = document.getElementById('editorOctaveDropdownOriginal').value;

                  if (newLetter === 'R') {
                      updateNoteInMeasure(editorSelectedMeasureIndex, selectedNote.id, { isRest: true, name: "R" });
                  } else {
                      const newName = `${newLetter}${newAccidental}${newOctave}`;
                      updateNoteInMeasure(editorSelectedMeasureIndex, selectedNote.id, { name: newName, isRest: false });
                  }
              } else if (target.id === 'editorDurationDropdownOriginal') {
                  updateNoteInMeasure(editorSelectedMeasureIndex, selectedNote.id, { duration: target.value });
              } else if (target.classList.contains('chord-note-letter') ||
                         target.classList.contains('chord-note-accidental') ||
                         target.classList.contains('chord-note-octave')) {
                  updateChordFromUI();
                  return;
              }
              drawAll(getMeasures());
              renderNoteEditBox();
          });
      }


      // OLD UI: Expanded Editor Actions
      document.getElementById('editorRemoveNoteOriginal')?.addEventListener('click', (event) => { event.preventDefault(); removeNoteFromMeasure(editorSelectedMeasureIndex, editorSelectedNoteId); editorSelectedNoteId = null; drawAll(getMeasures()); renderNoteEditBox(); });
      document.getElementById('editorToggleClefOriginal')?.addEventListener('click', (event) => { event.preventDefault();
          const measures = getMeasures();
          const currentMeasure = measures[editorSelectedMeasureIndex];
          const note = currentMeasure ? currentMeasure.find(n => n.id === editorSelectedNoteId) : null;
          if (note) updateNoteInMeasure(editorSelectedMeasureIndex, note.id, { clef: note.clef === 'treble' ? 'bass' : 'treble' });
          drawAll(getMeasures());
          renderNoteEditBox();
      });
      document.getElementById('editorToggleRestOriginal')?.addEventListener('click', (event) => { event.preventDefault();
          const measures = getMeasures();
          const currentMeasure = measures[editorSelectedMeasureIndex];
          const note = currentMeasure ? currentMeasure.find(n => n.id === editorSelectedNoteId) : null;
          if (note) {
              const newIsRest = !note.isRest;
              let newName = note.name;
              if (newIsRest) { newName = "R"; } else if (note.isRest) { newName = "C4"; }
              updateNoteInMeasure(editorSelectedMeasureIndex, note.id, { isRest: newIsRest, name: newName });
          }
          drawAll(getMeasures());
          renderNoteEditBox();
      });
      document.getElementById('editorMoveToPrevMeasureOriginal')?.addEventListener('click', (event) => { event.preventDefault();
          if (editorSelectedNoteId !== null && editorSelectedMeasureIndex > 0) {
              moveNoteBetweenMeasures(editorSelectedMeasureIndex, editorSelectedNoteId, editorSelectedMeasureIndex - 1);
              editorSelectedNoteId = null;
              drawAll(getMeasures());
              renderNoteEditBox();
          }
      });
      document.getElementById('editorMoveToNextMeasureOriginal')?.addEventListener('click', (event) => { event.preventDefault();
          if (editorSelectedNoteId !== null) {
              moveNoteBetweenMeasures(editorSelectedMeasureIndex, editorSelectedNoteId, editorSelectedMeasureIndex + 1);
              editorSelectedNoteId = null;
              drawAll(getMeasures());
              renderNoteEditBox();
          }
      });
      document.getElementById('addNoteToChordBtn')?.addEventListener('click', (event) => { event.preventDefault(); addNoteToChordUI(); });


      // NEW UI specific initializations
      setupPaletteDrag();
      // setupStaffInteractions(); // This function from mockup only, relies on mockup's div structure, not VexFlow
      setupContextMenu();
      setupNoteTooltips(); // This will setup listeners for the new editing panel
      setDefaultDuration();

      // Setup duration dropdown for OLD UI (this needs to be populated)
      const originalDurationDropdown = document.getElementById('editorDurationDropdownOriginal');
      if (originalDurationDropdown) {
          DURATIONS.forEach(duration => {
              const option = document.createElement('option');
              option.value = duration.key;
              option.textContent = duration.name;
              originalDurationDropdown.appendChild(option);
          });
      }

      // Populate octave dropdown for OLD UI single notes
      const originalOctaveDropdown = document.getElementById('editorOctaveDropdownOriginal');
      if (originalOctaveDropdown) {
          originalOctaveDropdown.innerHTML = '';
          for (let i = 2; i <= 7; i++) {
              const option = document.createElement('option');
              option.value = i.toString();
              option.textContent = i.toString();
              originalOctaveDropdown.appendChild(option);
          }
      }

      // This is the primary entry point for interaction with the rendered VexFlow score
      // Ensure this is called *after* drawAll has had a chance to render the score divs
      // And that handleMeasureClick/handleNoteClick are correctly defined above.
      enableScoreInteraction(handleMeasureClick, handleNoteClick);

      renderNoteEditBox(); // Initial render of the editor UI based on current state
      console.log("✓ Consolidated Editor UI initialized successfully");
  }

  document.addEventListener('DOMContentLoaded', () => {
      initializeConsolidatedEditorUI();
  });

  // Custom event listener for note drop from scoreRenderer.js
  // This listener needs to be outside the initialize function if it's a global event.
  document.addEventListener('noteDropped', (event) => {
      const { fromMeasureIndex, fromNoteId, toMeasureIndex, insertPosition, clefChanged, pitchChanged, newClef, newPitch } = event.detail;
      console.log("🎉 noteDropped event received in consolidated UI:", event.detail);

      const measures = getMeasures();
      const originalNote = measures[fromMeasureIndex]?.find(note => note.id === fromNoteId);

      if (!originalNote) {
          console.error("noteDropped: Original note not found in data model. Cannot process drop.");
          return;
      }

      if (fromMeasureIndex !== toMeasureIndex) {
          console.log(`noteDropped: Moving note from measure ${fromMeasureIndex} to ${toMeasureIndex}`);
          const noteToMove = removeNoteFromMeasure(fromMeasureIndex, fromNoteId);
          if (noteToMove) {
              if (clefChanged) { noteToMove.clef = newClef; }
              if (pitchChanged) { noteToMove.name = newPitch; }
              addNoteToMeasure(toMeasureIndex, noteToMove, insertPosition);
              editorSelectedMeasureIndex = toMeasureIndex;
              editorSelectedNoteId = noteToMove.id;
              console.log(`noteDropped: Note successfully moved and updated.`);
          } else {
              console.error("noteDropped: Failed to remove original note during move operation.");
          }
      } else if (clefChanged || pitchChanged) {
          console.log(`noteDropped: Updating note within measure ${fromMeasureIndex}. Clef changed: ${clefChanged}, Pitch changed: ${pitchChanged}`);
          const updatedNoteData = {};
          if (clefChanged) { updatedNoteData.clef = newClef; }
          if (pitchChanged) { updatedNoteData.name = newPitch; }
          updateNoteInMeasure(fromMeasureIndex, fromNoteId, updatedNoteData);
          editorSelectedNoteId = fromNoteId;
          console.log(`noteDropped: Note updated in place with clef ${newClef} and pitch ${newPitch}.`);
      } else {
          console.log("noteDropped: No measure, clef, or pitch change detected. No action taken on data model.");
      }

      drawAll(getMeasures()); // Re-render the UI to reflect changes
      renderNoteEditBox(); // Update editor display based on changes
      // scrollToMeasure(editorSelectedMeasureIndex); // Assuming this is defined and works
  });
</script>